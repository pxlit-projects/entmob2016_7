{"Name":"Monkey.Robotics - Beta","Id":1046,"Alias":"Monkey.Robotics","Description":"# Monkey.Robotics\n\nMonkey.Robotics greatly simplifies the task of building complex [.NET Microframework (MF)](http://netmf.com) powered robots and communicating with them from within Xamarin apps. With Monkey.Robotics, you can use C# through the entire stack, not just the Mobile Apps, but also on .NET MF microcontrollers. You can also use it to communicate with non-.NET MF microcontroller such as the Arduino.\n\n\n\nMonkey.Robotics is a full-stack framework that aims to make Robotics and Wearable development much easier by providing a foundation that provides core functionality both for bulding both mobile apps that are Wearables/Robotics aware, as well as [.NET Micro Framework](http://netmf.com) based applications that run on microcontrollers such as the Netduino and use peripherals such as sensors, servor, actuators, motor drivers, etc.\n\n## Architecture\n \nIt is split into two major platform stacks:\n\n * **Mobile Stack** - The _Mobile Stack_ is built in C# and runs on iOS, Android, and Windows Phone via the [Xamarin platform](http://xamarin.com) and contains features for communicating with wearables such as health monitoring devices and smartwatches, as well as microcontrollers such as the Netduino and Arduino.\n * **Microcontroller Stack** - The _Microcontroller Stack_ is built with C# and runs on [.NET Micro Framework](http://www.netmf.com/) compatible microcontroller platforms such as the [Netduino](http://netduino.com/).\n \nThe following diagram illustrates the topology of the entire stack:\n\n\n\n### Mobile Stack\n\nThe Mobile stack consists of three different parts:\n\n * **Low-level Bluetooth LE (BLE) API** - A cross-platform API (iOS and Android only right now) that supports communicating with BLE devices.\n * **Low-Level Wifi API** - A cross-platform API (iOS and Android only right now) that supports connecting to WiFi enabled devices. Note: this API is still in progress and has not yet shipped. For now, please use the BLE API.\n * **Messaging Framework** - A high-level cross-platform protocol for messaging peripherals via WiFi or BLE.\n * **Peripheral Libraries** - Strongly typed libraries for communicating with various vendor-specific peripherals such as health monitoring devices, smart watches, and the like.\n\n### Microcontroller Stack\n\nThe Microcontroller stack consists of two parts:\n\n * **Low-level Hardware Abstraction** - This is a modular/compositable based on the concept of _Blocks_ and _Scopes_ that represent devices and listeners, accordingly.\n * **Sensor and Peripheral Library** - Strongly typed libraries that do the heavy lifting of integration with hundreds of popular sensors spanning the gamut from Alcohol Sensors to 3-axis Accelerometers.\n\n \nThe Microcontroller stack uses reactive-like design patterns, in that it consists of composable **Blocks** that can be connected together to automatically bind output from one item into another. It also includes the notion of **Scopes**, which take the output from a block and do interesting things with it, such as transform it.\n\nFor example, the following program blinks the Netduino\u0027s onboard LED when the onboard button is pressed:\n \n```csharp\npublic class Program\n{\n\t// create our pin references.\n\t// note, when you create a reference to the onboard button, netduino is \n\t// smart enough to not use it as a reset button. :)\n\tstatic H.Cpu.Pin buttonHardware = Pins.ONBOARD_BTN;\n\tstatic H.Cpu.Pin ledHardware = Pins.ONBOARD_LED;\n\n\tpublic static void Main()\n\t{\n\t\t// Create the blocks\n\t\tvar button = new DigitalInputPin (buttonHardware);\n\t\tvar led = new DigitalOutputPin (ledHardware);\n\n\t\t// Connect them together. with the block/scope architecture, you can think\n\t\t// of everything as being connectable - output from one thing can be piped\n\t\t// into another. in this case, we\u0027re setting the button output to the LED\n\t\t// input. so when the user presses on the button, the signal goes straight\n\t\t// to the LED.\n\t\tbutton.Output.ConnectTo (led.Input);\n\n\t\t// keep the program alive\n\t\twhile (true) {\n\t\t\tSystem.Threading.Thread.Sleep (1000);\n\t\t}\n\t}\n}\n``` \n# Getting Started\nFor complete getting started tutorials, API docs, samples, and source, head over to the [Monkey.Robotics Github Page](https://github.com/xamarin/Monkey.Robotics)","Version":"0.5","Summary":"Create robotic projects and integrate them with Xamarin apps.","QuickStart":"# Getting Started with the Mobile Stack\n\nThe Mobile Stack of Xamarin.Robotics makes communication with the Micro Stack easy by providing a cross-platform Bluetooth Low-Energy (BLE) API.\n\nThe following code can be seen in action in the BLE Explorer sample app included in the component. It\u0027s also availabe in the [Monkey.Robotics Github repo](https://github.com/xamarin/Monkey.Robotics/tree/master/Sample%20Apps/BLE%20Explorer).\n\n## Get a Reference to the Adapter\n\nIn order to connect to BLE devices, the first thing that you\u0027ll need to do is get a  reference to the Adapter. The Adapter gives you access to BLE communication functions. A single adapter is used across your entire app, and is available as the static `Current` property on the Adapter class:\n\n```csharp\nApp.SetAdapter (Adapter.Current);\n```\n\n## Enumerating Devices\n\nOnce you have your adapter, you can start device scanning via `StartScanningForDevice` and pass an empty GUID if you don\u0027t want to scan for any particular device, but instead want to enumerate them all:\n\n```csharp\nadapter.StartScanningForDevices(Guid.Empty);\n\n```\n\n## Connecting to a Device\n\nAn IDevice reference is passed every time a device is discovered:\n\n\n```csharp\nadapter.DeviceDiscovered += (object sender, DeviceDiscoveredEventArgs e) =\u003e {\n\tDevice.BeginInvokeOnMainThread(() =\u003e {\n\t\tdevices.Add (e.Device);\n\t});\n};\n```\n\nTo connect to that device, simply call `ConnectToDevice` on the adapter and pass the IDevice reference:\n\n```csharp\nadapter.ConnectToDevice (device); \n```\n\n## Enumerating Services\n\nOnce the Device is connected, you can enumerate the services on it by calling `DiscoverServices`.\n\n```csharp\n\nadapter.DeviceConnected += (s, e) =\u003e {\n\tdevice = e.Device; // do we need to overwrite this?\n\n\t// when services are discovered\n\tdevice.ServicesDiscovered += (object se, EventArgs ea) =\u003e {\n\t\tDebug.WriteLine(\"device.ServicesDiscovered\");\n\t\t//services = (List\u003cIService\u003e)device.Services;\n\t\tif (services.Count == 0)\n\t\t\tDevice.BeginInvokeOnMainThread(() =\u003e {\n\t\t\t\tforeach (var service in device.Services) {\n\t\t\t\t\tservices.Add(service);\n\t\t\t\t}\n\t\t\t});\n\t};\n\t// start looking for services\n\tdevice.DiscoverServices ();\n\n};\n```\n\n## Enumerating Characteristics\n\nYou can enumerate the characteristics for a service by calling `DiscoverCharacteristics` on the Service itself:\n\n```csharp\n// when characteristics are discovered\nservice.CharacteristicsDiscovered += (object sender, EventArgs e) =\u003e {\n\tDebug.WriteLine(\"service.CharacteristicsDiscovered\");\n\tif (characteristics.Count == 0)\n\t\tDevice.BeginInvokeOnMainThread(() =\u003e {\n\t\t\tforeach (var characteristic in service.Characteristics) {\n\t\t\t\tcharacteristics.Add(characteristic);\n\t\t\t}\n\t\t});\n};\n\n// start looking for characteristics\nservice.DiscoverCharacteristics ();\n\n```\n\n\n\n# Getting Started with the Micro Stack\n\n## Step 1 - Setup your Netduino + Build Environment\n\nThe first step in getting started is to get your Netduino up and running, and get your development environment setup. Follow [these instructions](https://github.com/xamarin/Monkey.Robotics/blob/master/Getting%20Started/ConfiguringBuildEnv.md) to do just that.\n\n## Step 2 - Create a First Microframework/Netduino App\n\nOnce you\u0027ve got your [build environment and hardware](https://github.com/xamarin/Xamarin.Robotics/blob/master/Getting%20Started/SettingUpYourNetduino.md) setup, it\u0027s time to create your first Microframework App. In this guide, we\u0027re going to build and deploy a simple app that blinks the onboard LED on the Netduino board.\n\n#### Xamarin Studio\n\n 1. Launch Xamarin Studio and create a new solution of type **C# \u003e MicroFramework \u003e MicroFramework Console Applicaiton** and name it whatever you want.\n\n 2. Double-click on the **References** folder in the Solution Pad and add:\n \t* Microsoft.Spot.Hardware\n \t* SecretLabs.NETMF.Hardware\n \t* SecretLabs.NETMF.Harware.Netduino (or NetduinoPlus if that\u0027s what you\u0027re using)\n \t\n#### Visual Studio\n\n 1. Launch Visual Studio and create a new solution of type **Visual C# \u003e Micro Framework \u003e Console Application** and name it whatever you want.\n \n2. Right-click on the **References** folder in the Solution Explorer and add:\n \t* Microsoft.Spot.Hardware\n \t* SecretLabs.NETMF.Hardware\n \t* SecretLabs.NETMF.Harware.Netduino (or NetduinoPlus if that\u0027s what you\u0027re using)\n\n\n### Add the Robotics.Micro.Core Dlls\n\nDownload the Robotics.Micro.Core.dll (as well as **pe** and **le** directories) from [here](https://github.com/xamarin/Monkey.Robotics/tree/master/Binaries). Copy them to your project directory, and then add them as a reference.\n\n### Add the Code\n\nAfter you\u0027ve created the project and configured the references, add the following code to your program.cs file. Not that you might want to modify the namespace declaration to match your projet\u0027s name:\n\n```csharp\npublic class Program\n{\n\t// create our pin references.\n\t// note, when you create a reference to the onboard button, netduino is \n\t// smart enough to not use it as a reset button. :)\n\tstatic H.Cpu.Pin buttonHardware = Pins.ONBOARD_BTN;\n\tstatic H.Cpu.Pin ledHardware = Pins.ONBOARD_LED;\n\n\tpublic static void Main()\n\t{\n\t\t// Create the blocks\n\t\tvar button = new DigitalInputPin (buttonHardware);\n\t\tvar led = new DigitalOutputPin (ledHardware);\n\n\t\t// Connect them together. with the block/scope architecture, you can think\n\t\t// of everything as being connectable - output from one thing can be piped\n\t\t// into another. in this case, we\u0027re setting the button output to the LED\n\t\t// input. so when the user presses on the button, the signal goes straight\n\t\t// to the LED.\n\t\tbutton.Output.ConnectTo (led.Input);\n\n\t\t// keep the program alive\n\t\twhile (true) {\n\t\t\tSystem.Threading.Thread.Sleep (1000);\n\t\t}\n\t}\n}\n\n``` \n\n## Deploy and Test\n\n#### Xamarin Studio\n\n 1. Make sure your Netduino is plugged in. It should show up in the build bar at the top.\n\n 2. Hit the \"\u003e\" button to deploy.\n \nThe app should deploy. It may take a couple minutes. You can watch the deployment progress in the **Application Output** window.\n\nOnce the app has been deployed, you can press the button on the Netduino and the LED should light up!\n\n \n#### Visual Studio\n\n 1. Make sure your Netduino is plugged in.\n  \t\n 2. Double-click on the **Properties** item in the Solution Explorer, select **.NET Micro Framework** on the left, and the under **Deployment** choose **USB** and in the **Device** drop down, choose your Netduino device.\n\n 3. Click the **Start \u003e** button in the toolbar to deploy to yoru device.\n \nOnce the app has been deployed, you can press the button on the Netduino and the LED should light up!\n\n\n## More Detailed Documentation\n\nFor more detailed documenation and other projects, checkout the [project home on Github](https://github.com/xamarin/Monkey.Robotics).\n","Hash":"b76141f26a3b2bf1972bd8bfb0f35187","TargetPlatforms":["ios","android"],"TrialHash":null}